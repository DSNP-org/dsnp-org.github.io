{"componentChunkName":"component---src-templates-post-js","path":"/untitled/","result":{"data":{"ghostPost":{"id":"Ghost__Post__62684fcedcd6a1000166d4c9","title":"Concept Series 02: Source-Dependent Messages","slug":"untitled","featured":false,"feature_image":null,"excerpt":"[Ed Note: Check out the DSNP Forum\n[https://forums.projectliberty.io/t/about-the-concept-posts-category/203] to\nfollow community discussions around this new series of short essays that\ndescribe some of the concepts behind DSNP, what we've learned as we've built out\nthe protocol, and where we're going.]\n\nThis is the second in a series of posts laying out what we have learned in the\nchain search and concepts that are needed to understand where we are going.\n(Read the previous post on our Forum at ","custom_excerpt":null,"visibility":"public","created_at_pretty":"26 April, 2022","published_at_pretty":"26 April, 2022","updated_at_pretty":"04 May, 2022","created_at":"2022-04-26T20:02:22.000+00:00","published_at":"2022-04-26T20:04:52.000+00:00","updated_at":"2022-05-04T22:24:37.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"DSNP.org","slug":"dsnp","bio":null,"profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"DSNP.org","slug":"dsnp","bio":null,"profile_image":"https://static.ghost.org/v4.0.0/images/ghost-user.png","twitter":null,"facebook":null,"website":null},"primary_tag":null,"tags":[{"name":"#BlogPost","slug":"hash-blogpost","description":null,"feature_image":null,"meta_description":null,"meta_title":null,"visibility":"internal"}],"plaintext":"[Ed Note: Check out the DSNP Forum\n[https://forums.projectliberty.io/t/about-the-concept-posts-category/203] to\nfollow community discussions around this new series of short essays that\ndescribe some of the concepts behind DSNP, what we've learned as we've built out\nthe protocol, and where we're going.]\n\nThis is the second in a series of posts laying out what we have learned in the\nchain search and concepts that are needed to understand where we are going.\n(Read the previous post on our Forum at Concept Series 01: The Problems\n[https://forums.projectliberty.io/t/concept-series-01-the-problems/193].)\n\nEach time you tell the world that something exists, it creates a narrative that\nforms your identity. In a more technical definition, an identity is a construct\nformed by the aggregation of events from the same source. Each event or message\nis therefore source-dependent as messages without a source do not build an\nidentity.\n\nTransfers\n\nMost blockchain projects have focused on the concept of transfer. They have\nworked toward the questions around transfers: How can it be easier to transfer\nvalue from one user to another? How can these transfers be controlled\nprogrammatically? And even how can we create new unique items of value to\ntransfer to others? The advances in answers have led down a path that has\nparticular constraints.\n\nTransfer centric transactions require protecting against attacks such as the \ndouble-spend attack [https://en.wikipedia.org/wiki/Double-spending]. A transfer\nrequires confirmation of ownership before that ownership can be transferred.\nThis means that transfer transactions must be well ordered, have a higher level\nof validation and security, and can only be processed in series or other\nguarantees against interactions with other transactions.\n\nSource-Dependent Creation\n\nSocial networking is a world not dependent on transferring value. Each piece of\nthe narrative that creates the identity is starting fresh from the source. Other\ndata in social networks may then refer to the content, but do not alter it. The\nonly requirement is that each new creation is able to be linked to the creator.\n\nScientific data, supply chain checkpoints, and more share the characteristic\nthat they need proof of who sent the message, but do not need any proof of\ntransfer. This is the idea of an audit. We can follow the trail of who said what\nwhen and discover any falsehoods. Trust, but verify.\n\nHow does that verification happen? The simplest version of source validation is\na cryptographic signature [https://en.wikipedia.org/wiki/Digital_signature].\nMathematical proof that only the holder of a private key could have signed the\nmessage. We can extend the capabilities of a signature through a secure\nblockchain state that links public keys together (our next concept post). The\nkey is that the validation be easy and quick. Fast validation allows for invalid\nsignatures and messages to be rejected quickly with no chance of being mistaken\nfor an original. Once we focus on the source validation requirement, we can\ncreate two new features not possible in a traditional blockchain transfer\ntransaction: off-chain validation and parallel processing.\n\nFeatures\n\nAny action on-chain is expensive. Each action must be performed, replicated, and\nconfirmed by consensus. The result of those actions is guaranteed with the\nhighest possible trust level available to the chain. The cost for that guarantee\nis usually high and borne by the sender of the transaction. Off-chain actions\nhave a different cost profile. The action must be done for each consumer of the\ntransaction. This shifts the cost from the creator of the transaction to the\nconsumer, from writing to reading. That shift is desirable when the primary\nvalue is in the consumption instead of the publication of the data.\n\nOur source-dependent messages don’t require a prior validation of chain state to\nexist. We can use the chain for propagation and existence of the message and\nmove the validation of the message source or creator off-chain. To make the cost\nof validation low, we use the chain to provide easy access to the necessary data\nfor validation. We get what is called in computer science a “lazy evaluation 1\n[https://en.wikipedia.org/wiki/Lazy_evaluation]” of message validity. Consumers\ndesire valid messages and the low-cost means that producers of messages can\nexpect that invalid messages will be discovered.\n\nSource-dependent messages are parallelizable by default. Parallel processing of\ntransactions is often seen as a holy grail of blockchain technology due to the\npotential performance improvements. Source-dependent messages do require some\nprevious state, the ability to know they are sourced correctly, but that is a\nfar more limited need (and off-chain possible).\n\nProblems: Race Conditions and Revocation\n\nOf course, there are some race conditions\n[https://en.wikipedia.org/wiki/Race_condition] (isn’t there always?). A\nsource-dependent message must be preceded by data needed to confirm the source.\nCryptographic signatures do provide us a way to confirm the source is the holder\nof a private key, but nothing beyond that. If the source is not merely a public\nkey, the identifier used must be associated with a public key before the message\ncan be tested or an invalid message would occur pending the proper association.\n\nThose familiar with signatures will already know the next problem: revocation.\nBest security practices encourage rotating keys from time to time so that if a\nprivate key is exposed, the damage can be limited. We must deal with how to\nremove a key from the identifier aka revocation of the permissions of a key to\nbe a future source of messages. Users may also need to revoke or change a\nmessage after it is created.\n\nSolving the Problems\n\nWe can solve the problems with applying a two layer approach to message\nvalidation. First, we check if the message has a valid source. This is based\nonly on data available at the time the message was sent. Because the historical\ndata doesn’t change, the result is immutable and can be cached indefinitely. A\nmessage with a valid source can never in the future be considered to have an\ninvalid source.\n\nThe second layer is more difficult because we need the ability to change the\nvalidity of messages in the future. Users, services, and others need to delete\nmessages that were unintended or where a permission was abused. In DSNP, we use \nTombstoning [https://en.wikipedia.org/wiki/Tombstone_(data_store)] and \nidempotent [https://en.wikipedia.org/wiki/Idempotence] state changes to\naccomplish. Tombstoning is a revocation of a previous announcement. It says that\nwhile that announcement did exist, you should consider it to not exist anymore.\nIdempotent state changes don’t remove a previous message, but shift the state to\na different value. Graph change announcements\n[https://spec.dsnp.org/DSNP/Types/GraphChange] shift the state of a graph\nconnection from unfollowed to followed.\n\nHowever it is done, the message or state is altered by a future message. It is a\nmuch more difficult search space as it is continuously expanding. Because some\nuse cases may desire just the immutable message, the second layer of future\nrevocation need not always be available, but it should always be considered.\nWhile computers might not, humans change their minds all the time and DSNP is a\ntool for human communication.\n\nAs we continue this series of concepts, the idea of source-dependent messages,\nthese creation focused messages, leads to more building blocks. Next in the\nseries, we explore how we can leverage the limited requirements and ability for\noff-chain validation to enable scaled batching through user delegation of trust.\n\nNext Concept Series 03: Batching Source-Dependent Messages with Delegation\n(coming soon…)","html":"<p>[Ed Note: Check out the <a href=\"https://forums.projectliberty.io/t/about-the-concept-posts-category/203\">DSNP Forum</a> to follow community discussions around this new series of short essays that describe some of the concepts behind DSNP, what we've learned as we've built out the protocol, and where we're going.]</p><p>This is the second in a series of posts laying out what we have learned in the chain search and concepts that are needed to understand where we are going. (Read the previous post on our Forum at <a href=\"https://forums.projectliberty.io/t/concept-series-01-the-problems/193\">Concept Series 01: The Problems</a>.)</p><p>Each time you tell the world that something exists, it creates a narrative that forms your identity. In a more technical definition, an identity is a construct formed by the aggregation of events from the same source. Each event or message is therefore source-dependent as messages without a source do not build an identity.</p><p><strong>Transfers</strong></p><p>Most blockchain projects have focused on the concept of transfer. They have worked toward the questions around transfers: How can it be easier to transfer value from one user to another? How can these transfers be controlled programmatically? And even how can we create new unique items of value to transfer to others? The advances in answers have led down a path that has particular constraints.</p><p>Transfer centric transactions require protecting against attacks such as the <a href=\"https://en.wikipedia.org/wiki/Double-spending\" rel=\"noopener nofollow ugc\">double-spend attack</a>. A transfer requires confirmation of ownership before that ownership can be transferred. This means that transfer transactions must be well ordered, have a higher level of validation and security, and can only be processed in series or other guarantees against interactions with other transactions.</p><p><strong>Source-Dependent Creation</strong></p><p>Social networking is a world not dependent on transferring value. Each piece of the narrative that creates the identity is starting fresh from the source. Other data in social networks may then refer to the content, but do not alter it. The only requirement is that each new creation is able to be linked to the creator.</p><p>Scientific data, supply chain checkpoints, and more share the characteristic that they need proof of who sent the message, but do not need any proof of transfer. This is the idea of an audit. We can follow the trail of who said what when and discover any falsehoods. Trust, but verify.</p><p>How does that verification happen? The simplest version of source validation is a <a href=\"https://en.wikipedia.org/wiki/Digital_signature\" rel=\"noopener nofollow ugc\">cryptographic signature</a>. Mathematical proof that only the holder of a private key could have signed the message. We can extend the capabilities of a signature through a secure blockchain state that links public keys together (our next concept post). The key is that the validation be easy and quick. Fast validation allows for invalid signatures and messages to be rejected quickly with no chance of being mistaken for an original. Once we focus on the source validation requirement, we can create two new features not possible in a traditional blockchain transfer transaction: off-chain validation and parallel processing.</p><p><strong>Features</strong></p><p>Any action on-chain is expensive. Each action must be performed, replicated, and confirmed by consensus. The result of those actions is guaranteed with the highest possible trust level available to the chain. The cost for that guarantee is usually high and borne by the sender of the transaction. Off-chain actions have a different cost profile. The action must be done for each consumer of the transaction. This shifts the cost from the creator of the transaction to the consumer, from writing to reading. That shift is desirable when the primary value is in the consumption instead of the publication of the data.</p><p>Our source-dependent messages don’t require a prior validation of chain state to exist. We can use the chain for propagation and existence of the message and move the validation of the message source or creator off-chain. To make the cost of validation low, we use the chain to provide easy access to the necessary data for validation. We get what is called in computer science a “<a href=\"https://en.wikipedia.org/wiki/Lazy_evaluation\" rel=\"noopener nofollow ugc\">lazy evaluation 1</a>” of message validity. Consumers desire valid messages and the low-cost means that producers of messages can expect that invalid messages will be discovered.</p><p>Source-dependent messages are parallelizable by default. Parallel processing of transactions is often seen as a holy grail of blockchain technology due to the potential performance improvements. Source-dependent messages do require some previous state, the ability to know they are sourced correctly, but that is a far more limited need (and off-chain possible).</p><p><strong>Problems: Race Conditions and Revocation</strong></p><p>Of course, there are some <a href=\"https://en.wikipedia.org/wiki/Race_condition\" rel=\"noopener nofollow ugc\">race conditions</a> (isn’t there always?). A source-dependent message must be preceded by data needed to confirm the source. Cryptographic signatures do provide us a way to confirm the source is the holder of a private key, but nothing beyond that. If the source is not merely a public key, the identifier used must be associated with a public key before the message can be tested or an invalid message would occur pending the proper association.</p><p>Those familiar with signatures will already know the next problem: revocation. Best security practices encourage rotating keys from time to time so that if a private key is exposed, the damage can be limited. We must deal with how to remove a key from the identifier aka revocation of the permissions of a key to be a future source of messages. Users may also need to revoke or change a message after it is created.</p><p><strong>Solving the Problems</strong></p><p>We can solve the problems with applying a two layer approach to message validation. First, we check if the message has a valid source. This is based only on data available at the time the message was sent. Because the historical data doesn’t change, the result is immutable and can be cached indefinitely. A message with a valid source can never in the future be considered to have an invalid source.</p><p>The second layer is more difficult because we need the ability to change the validity of messages in the future. Users, services, and others need to delete messages that were unintended or where a permission was abused. In DSNP, we use <a href=\"https://en.wikipedia.org/wiki/Tombstone_(data_store)\" rel=\"noopener nofollow ugc\">Tombstoning</a> and <a href=\"https://en.wikipedia.org/wiki/Idempotence\" rel=\"noopener nofollow ugc\">idempotent</a> state changes to accomplish. Tombstoning is a revocation of a previous announcement. It says that while that announcement did exist, you should consider it to not exist anymore. Idempotent state changes don’t remove a previous message, but shift the state to a different value. <a href=\"https://spec.dsnp.org/DSNP/Types/GraphChange\" rel=\"noopener nofollow ugc\">Graph change announcements</a> shift the state of a graph connection from unfollowed to followed.</p><p>However it is done, the message or state is altered by a future message. It is a much more difficult search space as it is continuously expanding. Because some use cases may desire just the immutable message, the second layer of future revocation need not always be available, but it should always be considered. While computers might not, humans change their minds all the time and DSNP is a tool for human communication.</p><p>As we continue this series of concepts, the idea of source-dependent messages, these creation focused messages, leads to more building blocks. Next in the series, we explore how we can leverage the limited requirements and ability for off-chain validation to enable scaled batching through user delegation of trust.</p><p>Next Concept Series 03: Batching Source-Dependent Messages with Delegation (coming soon…)</p>","url":"https://ghost-cms.dsnp.org/untitled/","canonical_url":null,"uuid":"b2bf8899-2cda-40df-8a5f-c51d2e1c1b4b","page":null,"codeinjection_foot":null,"codeinjection_head":null,"codeinjection_styles":null,"comment_id":"62684fcedcd6a1000166d4c9","reading_time":4}},"pageContext":{"slug":"untitled"}},"staticQueryHashes":["1652489564","2561578252","2731221146","3995308582","4145280475"]}